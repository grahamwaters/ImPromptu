[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm.auto",
        "description": "tqdm.auto",
        "isExtraImport": true,
        "detail": "tqdm.auto",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "make_a_prompt",
        "kind": 2,
        "importPath": "prompt_generator",
        "description": "prompt_generator",
        "peekOfCode": "def make_a_prompt():\n    print(\"Welcome to the prompt generator!\")\n    print(\"-\"*50)\n    print(\"Here's how it works:\\nWhat would you like chatGPT to pretend to be? (this can be anything from a professional bowler, to a seasoned machine learning engineer)\\n\")\n    bot_type = input(\"Enter your preference: \")\n    print(\"-\"*50)\n    print(f'Received: \"{bot_type}\", excellent choice!\\n')\n    print(\"Now, what would you your first sentence to be? This can help guide the crafted prompt.\\n\")\n    first_sentence = input(\"Enter your first sentence: \")\n    print(\"-\"*50)",
        "detail": "prompt_generator",
        "documentation": {}
    },
    {
        "label": "generate_readme",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def generate_readme(industries, readme_file):\n    with open(readme_file, \"w\") as f:\n        f.write(\"# chatGPT Prompts For Everyone! *Domain Agnostic Prompts for Savvy Professionals* \\n## Industries List\\n\\n\")\n        for industry in industries:\n            f.write(f\"- [{industry}](./industries/{industry}.md)\\n\")\n# generate readme\n#!generate_readme(industries, \"README.md\")\n# create a folder for all of the industries\n#// os.remove(\"industries\")\n#!os.mkdir(\"industries\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "generate_readme_topics",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def generate_readme_topics(industries, readme_file, subfiles):\n    # Create the specific_topics folder if it doesn't already exist\n    if not os.path.exists(\"specific_topics\"):\n        os.makedirs(\"specific_topics\")\n    with open(readme_file, \"w\") as f:\n        f.write(\"# Industry List\\n\")\n        for industry in industries:\n            # Create subfiles for each programming language and technical program\n            for subfile in subfiles:\n                subfile_path = os.path.join(\"specific_topics\", f\"{subfile}.md\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "industries",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "industries = [\"Software Engineering\", \"UX Design\", \"Web Development\", \"Literature\", \"Art\", \"Music\", \"Film\", \"Photography\", \"Architecture\", \"Interior Design\", \"Graphic Design\", \"Fashion\", \"Product Design\", \"Industrial Design\", \"Game Design\", \"Animation\", \"Videography\", \"Journalism\", \"Advertising\", \"Marketing\", \"Public Relations\", \"Business\", \"Economics\", \"Finance\", \"Law\", \"Politics\", \"Psychology\", \"Sociology\", \"History\", \"Philosophy\", \"Religion\", \"Education\", \"Medicine\", \"Health\", \"Nutrition\", \"Fitness\", \"Sports\", \"Travel\", \"Food\", \"Cooking\", \"Crafts\", \"Home Improvement\", \"Gardening\", \"Pets\", \"Parenting\", \"Beauty\", \"Lifestyle\", \"Science\", \"Technology\", \"Mathematics\", \"Engineering\", \"Astronomy\", \"Chemistry\", \"Physics\", \"Biology\", \"Computer Science\", \"Data Science\", \"Robotics\", \"Entrepreneurship\", \"Personal Development\", \"Productivity\", \"Self Improvement\", \"Career Development\", \"Hobbies\", \"Languages\", \"Other\"]\nindustries = sorted(industries)\nindustries = [industry.lower().replace(\" \", \"_\") for industry in industries]\ndef generate_readme(industries, readme_file):\n    with open(readme_file, \"w\") as f:\n        f.write(\"# chatGPT Prompts For Everyone! *Domain Agnostic Prompts for Savvy Professionals* \\n## Industries List\\n\\n\")\n        for industry in industries:\n            f.write(f\"- [{industry}](./industries/{industry}.md)\\n\")\n# generate readme\n#!generate_readme(industries, \"README.md\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "industries",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "industries = sorted(industries)\nindustries = [industry.lower().replace(\" \", \"_\") for industry in industries]\ndef generate_readme(industries, readme_file):\n    with open(readme_file, \"w\") as f:\n        f.write(\"# chatGPT Prompts For Everyone! *Domain Agnostic Prompts for Savvy Professionals* \\n## Industries List\\n\\n\")\n        for industry in industries:\n            f.write(f\"- [{industry}](./industries/{industry}.md)\\n\")\n# generate readme\n#!generate_readme(industries, \"README.md\")\n# create a folder for all of the industries",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "industries",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "industries = [industry.lower().replace(\" \", \"_\") for industry in industries]\ndef generate_readme(industries, readme_file):\n    with open(readme_file, \"w\") as f:\n        f.write(\"# chatGPT Prompts For Everyone! *Domain Agnostic Prompts for Savvy Professionals* \\n## Industries List\\n\\n\")\n        for industry in industries:\n            f.write(f\"- [{industry}](./industries/{industry}.md)\\n\")\n# generate readme\n#!generate_readme(industries, \"README.md\")\n# create a folder for all of the industries\n#// os.remove(\"industries\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "subfiles",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "subfiles = [\"JavaScript\", \"Python\", \"C#\", \"Java\", \"C++\", \"C\", \"Ruby\", \"Swift\", \"PHP\", \"Go\", \"Rust\", \"Kotlin\", \"TypeScript\", \"generator\", \"mathematician\",\"physicist\",\"professor\",\"R\", \"Scala\", \"Perl\", \"Shell\", \"Objective-C\", \"SQL\", \"Excel Formulas\", \"Visio\", \"VBA\", \"Power BI\", \"SAS\",\n            \"Tableau\", \"QlikView\", \"D3.js\", \"Data Visualization\", \"Data Analysis\", \"Machine Learning\", \"Deep Learning\", \"algorithm\",\n            \"Computer Vision\", \"Natural Language Processing\", \"Data Science\", \"Big Data\", \"Data Engineering\", \"DevOps\",\n            \"Cloud Computing\", \"Docker\", \"Kubernetes\", \"AWS\", \"Azure\", \"Google Cloud\", \"Linux\", \"Windows\", \"macOS\", \"Detector\", \"Book\",\n            \"iOS\", \"Android\", \"Pointers in Computer Science\", \"Algorithms\", \"Data Structures\", \"Operating Systems\", \"Game\", \"Advice\", \"\"\n            \"Networking\", \"Security\", \"Cryptography\", \"Blockchain\", \"IoT\", \"AR/VR\", \"Computer Graphics\", \"Computer Architecture\",\n            \"Compilers\", \"Assembler\", \"Debugging\", \"Testing\", \"Agile\", \"Scrum\", \"Kanban\", \"Lean\", \"Waterfall\", \"PMP\", \"translate\",\n            \"PRINCE2\", \"ITIL\", \"COBIT\", \"TOGAF\", \"SOA\", \"Microservices\", \"Monolithic\", \"Functional Programming\", \"diet\", \"coach\",\"english\", \"Regex\", \"Full Stack Development\", \"Front End Development\", \"Back End Development\", \"Mobile Development\", \"Desktop Development\",\n            \"Object-Oriented Programming\", \"Procedural Programming\", \"Event-Driven Programming\", \"Concurrent Programming\", \"Creator\",\n            \"Distributed Systems\", \"Parallel Computing\", \"High-Performance Computing\", \"Embedded Systems\", \"Firmware\", \"Post\"]",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "subfiles",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "subfiles = sorted(subfiles)\nsubfiles = [sub.replace(\" \", \"_\").replace('.','_').replace('/','').lower() for sub in subfiles]\n# remove duplicates\nsubfiles = list(dict.fromkeys(subfiles))\ndef generate_readme_topics(industries, readme_file, subfiles):\n    # Create the specific_topics folder if it doesn't already exist\n    if not os.path.exists(\"specific_topics\"):\n        os.makedirs(\"specific_topics\")\n    with open(readme_file, \"w\") as f:\n        f.write(\"# Industry List\\n\")",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "subfiles",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "subfiles = [sub.replace(\" \", \"_\").replace('.','_').replace('/','').lower() for sub in subfiles]\n# remove duplicates\nsubfiles = list(dict.fromkeys(subfiles))\ndef generate_readme_topics(industries, readme_file, subfiles):\n    # Create the specific_topics folder if it doesn't already exist\n    if not os.path.exists(\"specific_topics\"):\n        os.makedirs(\"specific_topics\")\n    with open(readme_file, \"w\") as f:\n        f.write(\"# Industry List\\n\")\n        for industry in industries:",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "subfiles",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "subfiles = list(dict.fromkeys(subfiles))\ndef generate_readme_topics(industries, readme_file, subfiles):\n    # Create the specific_topics folder if it doesn't already exist\n    if not os.path.exists(\"specific_topics\"):\n        os.makedirs(\"specific_topics\")\n    with open(readme_file, \"w\") as f:\n        f.write(\"# Industry List\\n\")\n        for industry in industries:\n            # Create subfiles for each programming language and technical program\n            for subfile in subfiles:",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "create_prompts_csv",
        "kind": 2,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "def create_prompts_csv(markdown_file):\n    prompts_df = pd.DataFrame(columns = [\"topic\", \"prompt\", \"contributor\",\"link\"])\n    # read the markdown file, extract the prompts, and write them to a csv file\n    with open(markdown_file, \"r\") as f:\n        markdown_text = f.read()\n    # the first edge is the first \"##\" and the second edge is the next \"##\" or the end of the file\n    sections= re.split(r\"## \", markdown_text)[1:] # split the markdown text into sections\n    prompts = []\n    for section in tqdm(sections):\n        # the first edge is the first \"##\" and the second edge is the next \"##\" or the end of the file",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "extract_prompts",
        "kind": 2,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "def extract_prompts(markdown_file,TOPICS):\n    # assert that the markdown file exists, and that the topics are a list of strings.\n    assert os.path.exists(markdown_file), \"The markdown file does not exist.\"\n    assert isinstance(TOPICS, list), \"The topics must be a list of strings.\"\n    with open(markdown_file, \"r\") as f:\n        markdown_text = f.read()\n    for topic in tqdm(TOPICS, total = len(TOPICS)):\n        print(f\"Extracting prompts for {topic}...\")\n        # the first edge is the first \"##\" and the second edge is the next \"##\" or the end of the file\n        print(f\"Found {len(topic_prompts)} prompts for {topic}.\")",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "populate_files_from_csv",
        "kind": 2,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "def populate_files_from_csv():\n    # code to read csv file and create prompts_df here\n    # make sure the topics are in the TOPICS list\n    for topic_string in tqdm(TOPICS, total = len(TOPICS)):\n        with open(f\"specific_topics/{str(topic_string).replace(' ', '_')}.md\", \"a+\") as f: # open the file in append mode, create it only if it doesn't exist\n            # convert the topic_string topic back to a normal word (e.g. \"specific_topic\" -> \"specific topic\")\n            topic = topic_string.replace(\"_\", \" \")\n            # define a small data frame with only the rows where the topic matches the topic_string\n            prompts_df_sub = prompts_df[prompts_df['topic'] == topic_string]\n            # iterate through the rows of the data frame",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "def main():\n    create_prompts_csv(\"readme_other.md\")\n    # extract_prompts(\"readme_other.md\", TOPICS)\n    #!populate_files_from_csv() # populate the markdown files in the \"specific_topics\" folder with the prompts from the csv file\nif __name__ == \"__main__\":\n    main()",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "TOPICS",
        "kind": 5,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "TOPICS = os.listdir(\"specific_topics\") # get the list of file names in the \"specific_topics\" folder\nTOPICS = [topic.replace(\".md\", \"\") for topic in TOPICS] # remove the \".md\" from the file names\nTOPICS = [topic.replace(\"_\", \" \") for topic in TOPICS] # replace the underscores with spaces\nprompts_df = pd.read_csv(\"prompts.csv\")\nimport numpy as np\ndef create_prompts_csv(markdown_file):\n    prompts_df = pd.DataFrame(columns = [\"topic\", \"prompt\", \"contributor\",\"link\"])\n    # read the markdown file, extract the prompts, and write them to a csv file\n    with open(markdown_file, \"r\") as f:\n        markdown_text = f.read()",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "TOPICS",
        "kind": 5,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "TOPICS = [topic.replace(\".md\", \"\") for topic in TOPICS] # remove the \".md\" from the file names\nTOPICS = [topic.replace(\"_\", \" \") for topic in TOPICS] # replace the underscores with spaces\nprompts_df = pd.read_csv(\"prompts.csv\")\nimport numpy as np\ndef create_prompts_csv(markdown_file):\n    prompts_df = pd.DataFrame(columns = [\"topic\", \"prompt\", \"contributor\",\"link\"])\n    # read the markdown file, extract the prompts, and write them to a csv file\n    with open(markdown_file, \"r\") as f:\n        markdown_text = f.read()\n    # the first edge is the first \"##\" and the second edge is the next \"##\" or the end of the file",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "TOPICS",
        "kind": 5,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "TOPICS = [topic.replace(\"_\", \" \") for topic in TOPICS] # replace the underscores with spaces\nprompts_df = pd.read_csv(\"prompts.csv\")\nimport numpy as np\ndef create_prompts_csv(markdown_file):\n    prompts_df = pd.DataFrame(columns = [\"topic\", \"prompt\", \"contributor\",\"link\"])\n    # read the markdown file, extract the prompts, and write them to a csv file\n    with open(markdown_file, \"r\") as f:\n        markdown_text = f.read()\n    # the first edge is the first \"##\" and the second edge is the next \"##\" or the end of the file\n    sections= re.split(r\"## \", markdown_text)[1:] # split the markdown text into sections",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "prompts_df",
        "kind": 5,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "prompts_df = pd.read_csv(\"prompts.csv\")\nimport numpy as np\ndef create_prompts_csv(markdown_file):\n    prompts_df = pd.DataFrame(columns = [\"topic\", \"prompt\", \"contributor\",\"link\"])\n    # read the markdown file, extract the prompts, and write them to a csv file\n    with open(markdown_file, \"r\") as f:\n        markdown_text = f.read()\n    # the first edge is the first \"##\" and the second edge is the next \"##\" or the end of the file\n    sections= re.split(r\"## \", markdown_text)[1:] # split the markdown text into sections\n    prompts = []",
        "detail": "topic_sorting",
        "documentation": {}
    },
    {
        "label": "prompts_df",
        "kind": 5,
        "importPath": "topic_sorting",
        "description": "topic_sorting",
        "peekOfCode": "prompts_df = pd.read_csv(\"prompts.csv\")\n# Step 2: Populate the markdown files with the prompts from the csv file\ndef main():\n    create_prompts_csv(\"readme_other.md\")\n    # extract_prompts(\"readme_other.md\", TOPICS)\n    #!populate_files_from_csv() # populate the markdown files in the \"specific_topics\" folder with the prompts from the csv file\nif __name__ == \"__main__\":\n    main()",
        "detail": "topic_sorting",
        "documentation": {}
    }
]